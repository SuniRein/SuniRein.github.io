import{_ as e,c as d,a as n,b as a,e as i,d as k,w as h,r as t,o as r}from"./app-1dhAU6lT.js";const g={},y={class:"vp-steps"},A={class:"hint-container warning"},o={class:"hint-container note"},c={class:"hint-container tip"},D={class:"hint-container note"};function E(C,s){const l=t("VPLink"),p=t("Plot");return r(),d("div",null,[s[75]||(s[75]=n(`<h2 id="什么是-gmock" tabindex="-1"><a class="header-anchor" href="#什么是-gmock"><span>什么是 gMock？</span></a></h2><p>在编写原型（<em>prototype</em>）或测试时，完全依赖真实对象的行为往往不可行或不够明智。 <mark>模拟对象</mark>（<em>mock object</em>）实现了与真实对象相同的接口，可以替代真实对象。 你可以在运行时指定和观察模拟对象的行为，如“哪些方法会被调用？”“按什么顺序调用？”“调用多少次？”“使用什么参数？”“返回什么值？”等等。</p><p>人们常常会混淆<mark>伪对象</mark>（<em>fake object</em>）与模拟对象的概念。 在测试驱动开发（<em>TDD</em>）领域中，这两者有着本质区别：</p><ul><li><strong>伪对象</strong>实现了原有对象的功能，但通常采用某些简化方式（可能是为了降低运行成本），因此不适合生产环境。 内存文件系统就是一个典型案例。</li><li><strong>模拟对象</strong>只是按照对象原本的行为，预先设定了一些<mark>期望</mark>（<em>expectation</em>），而没有实现完整的功能。</li></ul><p>如果这些概念对你来说过于抽象，不必担心——你现在只需记住：模拟对象允许你验证其与被测代码之间的<strong>交互行为</strong>。 一旦开始实际使用，你就能清晰感受到这两者的区别。</p><p><mark>gMock</mark> 是一个用于创建和使用模拟对象类（以下简称“模拟类”）的库（有时也将其称为&quot;框架&quot;以彰显其专业性）。 它为 C++ 提供了与 Java 中的 jMock/EasyMock 类似的功能，虽然实现方式有所不同，但核心理念相通。</p><p>使用 gMock 时：</p><ol><li>首先通过一些简单的宏来描述你需要模拟的接口，这些宏会自动展开成模拟类的实现；</li><li>接着创建模拟对象，使用直观的语法来描述对象的期望（<em>expectation</em>）与行为；</li><li>最后执行那些使用模拟对象的代码。 gMock 会即时捕捉任何违反期望的情况。</li></ol><h2 id="为什么选择-gmock" tabindex="-1"><a class="header-anchor" href="#为什么选择-gmock"><span>为什么选择 gMock？</span></a></h2><p>虽然模拟对象能减少测试中不必要的依赖，使测试更加高效可靠，但在 C++ 中手动实现模拟对象十分<strong>困难</strong>：</p><ul><li>需要人工编写模拟类实现。这类工作通常枯燥且容易出错，许多开发者都避而远之。</li><li>手写编写的模拟对象质量参差不齐。 你可能看到精心设计的实现，也可能遇到仓促完成、充斥各种限制的版本。</li><li>通过使用某个模拟对象获得的经验难以运用到其他场景。</li></ul><p>相比之下，Java 和 Python 开发者拥有优秀的模拟框架（jMock、EasyMock 等），可以自动创建模拟对象。 在这些语言社区里，模拟被证明是一种高效的技术，在开发中得到广泛运用。 使用合适的工具为这些开发者带来了质的改变。</p><p>gMock 专为 C++ 开发者打造。 其设计灵感源自 jMock 和 EasyMock，同时充分考虑了 C++ 的语言特性。 如果你正面临以下问题，gMock 将成为你的得力助手：</p><ul><li>受困于某些次优设计，希望趁为时未晚进行更多原型验证，但 C++ 的原型开发缺乏效率。</li><li>测试因依赖过多库或使用昂贵资源（如数据库）而运行缓慢。</li><li>测试因使用不可靠资源（如网络）而不稳定。</li><li>需要测试代码对故障（如文件校验错误）的处理逻辑，但难以人为制造故障。</li><li>需要验证模块间的正确交互，但难以直接观测交互过程，因此只能通过观测最终副作用来间接判断。</li><li>希望模拟依赖项，但它们没有模拟版本，或者你对那些手写的笨拙模拟不感兴趣。</li></ul><p>我们建议你从两个维度来使用 gMock：</p><ul><li>作为<strong>设计工具</strong>：让你能够及早且更频繁地进行接口设计测试。更多迭代带来更优设计。</li><li>作为<strong>测试工具</strong>：减少测试的外部依赖；探究模块与其协作者之间的交互细节。</li></ul><h2 id="快速开始" tabindex="-1"><a class="header-anchor" href="#快速开始"><span>快速开始</span></a></h2><p>gMock 与 googletest 捆绑发布。</p><h2 id="模拟对象使用案例" tabindex="-1"><a class="header-anchor" href="#模拟对象使用案例"><span>模拟对象使用案例</span></a></h2><p>我们通过一个具体案例来理解模拟对象的作用。 假设你正在开发一个依赖 <a href="https://en.wikipedia.org/wiki/Logo_programming_language" target="_blank" rel="noopener noreferrer">LOGO</a> 风格 API 的绘图程序， 你会如何验证其绘制逻辑的正确性？ 直接运行程序并与基准屏幕快照（<em>golden screen snapshot</em>）对比看似可行，但这种测试方式存在明显缺陷：</p><ul><li>测试的运行成本高昂。</li><li>测试结果容易被破坏：如果你更换了一张新显卡，抗锯齿性能更好，你需要重新生成所有的基准图像。</li></ul><p>如果所有测试都采用这种方式，维护成本将难以承受。 <a href="https://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener noreferrer">依赖注入（<em>Dependency Injection</em>）</a> 提供了一种更好的解决方案：通过抽象接口隔离系统 API，解耦对象逻辑与具体实现。 我们可定义如下的 <code>Turtle</code> 接口：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  ...</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  virtual</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> ~Turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {}</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  virtual</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> PenUp</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  virtual</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> PenDown</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  virtual</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Forward</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> distance</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  virtual</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Turn</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> degrees</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  virtual</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> GoTo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> x</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> y</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  virtual</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> GetX</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> const</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  virtual</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> GetY</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> const</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span></code></pre></div><div class="hint-container warning"><p class="hint-container-title">注意</p><p><code>Turtle</code> 类的析构函数必须被声明为虚函数，否则将无法正确使用基类指针来删除派生类对象。</p></div><p>你可以用 <code>PenUp()</code> 和 <code>PenDown()</code> 来控制 <code>Trutle</code> 对象在移动时是否产生轨迹， 用 <code>Forward()</code>、<code>Turn()</code>、<code>GoTo()</code> 来控制对象的移动， 并用 <code>GetX()</code> 和 <code>GetY()</code> 来获取当前所处位置。</p><p>通过在实际运行中使用真实实现，而在测试中使用模拟实现，你可以</p><ul><li>精确获取程序调用不同绘图指令的顺序与调用参数。</li><li>增强测试的鲁棒性：测试不会因图形硬件差异而产生不同结果。</li><li>使测试易于阅读和维护：测试逻辑直接展现在代码中，而不是图像文件中。</li><li>大大提高测试运行速度。</li></ul><h2 id="编写模拟类" tabindex="-1"><a class="header-anchor" href="#编写模拟类"><span>编写模拟类</span></a></h2><p>有时你可能足够幸运，已经有人为你实现需要使用的模拟类了。 不过，即使你需要自己编写，也不必担心，gMock 使这个任务几乎成为一场有趣的游戏。</p><h3 id="如何定义模拟类" tabindex="-1"><a class="header-anchor" href="#如何定义模拟类"><span>如何定义模拟类？</span></a></h3><p>以 <code>Turtle</code> 接口为例，你需要遵循以下步骤：</p>`,31)),a("div",y,[a("ul",null,[s[3]||(s[3]=a("li",null,[i("从 "),a("code",null,"Turtle"),i(" 派生出 "),a("code",null,"MockTurtle"),i(" 类。")],-1)),a("li",null,[s[1]||(s[1]=i("选取要模拟的虚函数（尽管 gmock 支持",-1)),k(l,{href:"gmock_cook_book.md#mocking-non-virtual-methods"},{default:h(()=>s[0]||(s[0]=[i("通过模板模拟非虚函数",-1)])),_:1,__:[0]}),s[2]||(s[2]=i("， 但实现起来较为复杂）。",-1))]),s[4]||(s[4]=n("<li>在 <code>public:</code> 区域使用 <code>MOCK_METHOD()</code> 宏。</li><li>现在到了最重要的一步： 将函数签名拆分成返回类型、函数名和参数列表，分别作为宏的三个参数。</li><li>如果该函数为 <code>const</code> 修饰，添加 <code>(const)</code> 作为第四个参数（这里括号是必要的）。</li><li>由于你是在重写一个虚函数，我们建议给该函数添加 <code>override</code> 修饰。 如果函数已被 <code>const</code> 修饰，则将第四个参数改为 <code>(const, override)</code>，否则直接使用 <code>(override)</code>。</li><li>重复上述步骤，处理你要模拟的所有函数。 注意，即使不需要模拟，你也必须为所有纯虚函数提供一份实现。</li>",5))])]),s[76]||(s[76]=n(`<p>完成上述步骤后，你会得到类似下面的示例：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">include</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">gmock/gmock.h</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&gt;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 导入 gMock 库</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> MockTurtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> :</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> public</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  ...</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 模拟无参数方法</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  MOCK_METHOD</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> PenUp</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (),</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">override</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  MOCK_METHOD</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> PenDown</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (),</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">override</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 模拟有参数方法</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  MOCK_METHOD</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Forward</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> distance</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">),</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">override</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  MOCK_METHOD</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Turn</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> degrees</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">),</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">override</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  MOCK_METHOD</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> GoTo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> x</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> y</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">),</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">override</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 模拟 const 方法</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  MOCK_METHOD</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> GetX</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (),</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> override</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  MOCK_METHOD</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> GetY</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (),</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> override</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span></code></pre></div><p><code>MOCK_METHOD</code> 宏已经自动生成了所有必要的代码，因此你无需手动实现这些模拟方法。</p><h3 id="模拟类的存放位置" tabindex="-1"><a class="header-anchor" href="#模拟类的存放位置"><span>模拟类的存放位置</span></a></h3><p>你需要慎重考虑模拟类的存放位置。</p><p>很多人会将它直接放在 <code>_test.cc</code> 文件中。 当接口（这里假定为 <code>Foo</code>）与测试同属一个人或团队时，这样做是可行的。 否则，当 <code>Foo</code> 的所有者修改了接口了，测试可能会失效。 （你不能指望 <code>Foo</code> 的所有者来修复所有相关的测试。）</p><p>一般而言，你不应该模拟不属于你的类。 如果真的有这样做的必要，将定义存放在 <code>Foo</code> 所属的 Bazel 包中： 在同一目录或其 <code>testing</code> 子目录下创建一个 <code>.h</code> 头文件，并相应创建 <code>testonly=true</code> 的 <code>cc_library</code>。 这样每个人都可以在他们的测试中引入该模拟类，而一旦有变更发生，只需要修改这一处。</p><p>另一种更推荐的方式是引入一个 <code>FooAdaptor</code> 中间层——它完全属于你，因此你可以从容处理 <code>Foo</code> 接口变化的影响。 尽管这会增加初始开发成本，但一个合理的中间层相比 <code>Foo</code> 更能满足你的特定需求，从而可以提高代码的可读性和可维护性。</p><h2 id="using-mocks-in-tests" tabindex="-1"><a class="header-anchor" href="#using-mocks-in-tests"><span>在测试中使用模拟对象</span></a></h2><p>使用模拟对象的典型工作流程如下：</p><div class="vp-steps"><ol><li>从 <code>testing</code> 命名空间中导入需要使用的 gMock 符号。</li><li>创建模拟对象的实例。</li><li>设置模拟对象的期望，如方法的调用次数、调用参数和行为模式等。</li><li>运行使用模拟对象的测试代码，可搭配 googletest 断言来验证结果。</li><li>当模拟对象析构时，gMock 会自动检测所有期望是否满足。</li></ol></div><p>以下为完整示例（对应步骤已用编号标注好）：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">include</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">path/to/mock-turtle.h</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">include</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">gmock/gmock.h</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">include</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">gtest/gtest.h</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">AtLeast</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                      // #1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">TEST</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">PainterTest</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> CanDrawSomething</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  MockTurtle turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                           // #2</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> PenDown</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">               // #3</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">      .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Times</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">AtLeast</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  Painter </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">painter</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                    // #4</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  EXPECT_TRUE</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">painter</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">DrawCircle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 10</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                                              // #5</span></span></code></pre></div><p>上述测试验证 <code>PenDown()</code> 方法会被调用至少一次。 如果 <code>painter</code> 实际上没有调用 <code>PenDown()</code> 方法，测试会失败并输出以下信息：</p><div class="language-ansi" data-highlighter="shiki" data-ext="ansi" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-ansi"><span class="line"><span style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;">path/to/my_test.cc:119: Failure</span></span>
<span class="line"><span style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;">Actual function call count doesn&#39;t match this expectation:</span></span>
<span class="line"><span style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;">Actually: never called;</span></span>
<span class="line"><span style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;">Expected: called at least once.</span></span>
<span class="line"><span style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;">Stack trace:</span></span>
<span class="line"><span style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;">...</span></span></code></pre></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>在 Emacs 中可直接在错误行号上敲击回车，以跳转到未通过的期望的位置。</p></div><div class="hint-container warning"><p class="hint-container-title">注意</p><p>如果模拟对象没有被析构，对期望值的验证将不会发生。 因此，最好在测试中启用堆检查器。 <code>gtest_main</code> 中已经自动启用该机制。</p></div><div class="hint-container important"><p class="hint-container-title">设置期望的注意事项</p><p>gMock 要求必须在模拟方法被调用<strong>之前</strong>设置期望，否则将导致<strong>未定义行为</strong>。 禁止在模拟方法的调用过程中穿插设置期望，以及在调用结束后设置期望。</p><p>这意味着 <code>EXPECT_CALL()</code> 应被理解为对<strong>未来</strong>调用的期望，而不是对过去行为的验证。 gMock 采用这种设计，旨在当期望未通过时能立即报错，同时保留完整的运行上下文（如堆栈信息），提高调试效率。</p></div><p>尽管本例较为简单，即使不用 gMock 也能轻松实现类似的效果，但 gMock 的威力远不止于此。 在后面的进一步学习后，你便能对 gMock 的强大有所体会。</p><h2 id="setting-expectations" tabindex="-1"><a class="header-anchor" href="#setting-expectations"><span>设置期望</span></a></h2><p>设置合适的期望是正确用好模拟对象的关键。 如果期望设置得过于严格，测试可能会因无关的更改而失败； 如果设置得过于宽松，又可能无法发现潜在的错误。 你需要找到合适平衡点，让测试能精确捕获应该发现的错误类型。 gMock 提供了实现这种平衡的必要工具。</p><h3 id="基本语法" tabindex="-1"><a class="header-anchor" href="#基本语法"><span>基本语法</span></a></h3><p>在 gMock 中，我们使用 <code>EXPECT_CALL()</code> 宏来为模拟方法设置期望。其基本语法为：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">mock_object</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> method</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">matchers</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Times</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">cardinality</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillOnce</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">action</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillRepeatedly</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">action</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre></div><p>该宏接受两个参数，第一个是模拟对象，第二个是要模拟的方法和参数。 出于技术原因，你应该用 <code>,</code> 而不是用 <code>.</code> 隔开两者。 若方法没有重载，<code>matcher</code> 可以被省略：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">mock_object</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> non</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">overloaded</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">method</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Times</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">cardinality</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillOnce</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">action</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillRepeatedly</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">action</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre></div><p>这种语法允许测试编写者在表示“允许用任意参数调用该方法”时，无需显式指定参数数量或类型。 为避免产生歧义，该语法仅适用于无重载的方法。</p><p>这两种形式的语法后均可接若干子句，用来提供更详细的期望描述。 我们将在后续章节中讨论不同子句的作用。</p><p>这种语法设计旨在让期望设置读起来像自然语言。 例如，你可能猜到以下代码：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> GetX</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Times</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillOnce</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">100</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillOnce</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">150</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillRepeatedly</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">200</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span></code></pre></div><p>表示 <code>Turtle</code> 对象的 <code>GetX()</code> 方法将被调用五次： 第一次返回 100，第二次返回 150，剩下每次都返回 200。 有些人将这种语法风格称为<strong>领域特定语言</strong>（<em>Domain-Specific Language</em>, <em>DSL</em>）。</p><div class="hint-container info"><p class="hint-container-title">为什么使用宏来设置期望？</p><p>这主要出于两个目的： 一是让期望易于识别，无论是通过 <code>grep</code> 等工具还是人工阅读代码； 二是允许 gMock 在错误消息中包含期望的源码位置，便于调试。</p></div><h3 id="matchers-what-arguments-do-we-expect" tabindex="-1"><a class="header-anchor" href="#matchers-what-arguments-do-we-expect"><span>匹配器：对参数值的期望</span></a></h3><p>当模拟方法接收参数时，我们可以指定期望的参数值，例如：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 期望 turtle 前进 50 个单位</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Forward</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">100</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span></code></pre></div><p>但通常我们不希望参数限定过于严格——这会降低测试的稳定性。 因此我们建议只做必要的参数限定。 如果你不关心参数值，可以使用 <code>_</code> 作为参数。</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">_</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 期望 turtle 跳转到 x=50 轴线上的任意位置</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> GoTo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">50</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> _</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span></code></pre></div><p><code>_</code> 是表示“允许任意值”的<mark>匹配器</mark>（<em>matcher</em>）。 匹配器类似于谓词，可以验证参数是否符合预期。 在 <code>EXPECT_CALL()</code> 中，任何需要函数参数的地方都可以使用匹配器。</p>`,38)),a("p",null,[s[7]||(s[7]=i("上面示例中的 ",-1)),s[8]||(s[8]=a("code",null,"100",-1)),s[9]||(s[9]=i(" 和 ",-1)),s[10]||(s[10]=a("code",null,"50",-1)),s[11]||(s[11]=i(" 也是匹配器，它们等价于 ",-1)),s[12]||(s[12]=a("code",null,"Eq(100)",-1)),s[13]||(s[13]=i(" 和 ",-1)),s[14]||(s[14]=a("code",null,"Eq(50)",-1)),s[15]||(s[15]=i("，表示函数参数必须与匹配器参数相等（使用 ",-1)),s[16]||(s[16]=a("code",null,"operator==",-1)),s[17]||(s[17]=i("）。 gMock 为常见类型提供了许多",-1)),k(l,{href:"reference/matchers.md"},{default:h(()=>s[5]||(s[5]=[i("内置匹配器",-1)])),_:1,__:[5]}),s[18]||(s[18]=i("，同时也支持",-1)),k(l,{href:"gmock_cook_book.md#new-matchers"},{default:h(()=>s[6]||(s[6]=[i("自定义匹配器",-1)])),_:1,__:[6]}),s[19]||(s[19]=i("。 例如：",-1))]),s[77]||(s[77]=n(`<div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Ge</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 期望 turtle 前进至少 100 个单位</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Forward</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Ge</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">100</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)));</span></span></code></pre></div><p>如果你完全不关心参数值，可以省略参数列表，而不必将每个参数标注为 <code>_</code>：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// Expects the turtle to move forward.</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Forward</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// Expects the turtle to jump somewhere.</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> GoTo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre></div>`,3)),a("p",null,[s[21]||(s[21]=i("不过，这种语法仅适用于没有重载的方法。 如果方法存在重载，需通过指定参数数量甚至",-1)),k(l,{href:"gmock_cook_book.md#select-overload"},{default:h(()=>s[20]||(s[20]=[i("参数类型",-1)])),_:1,__:[20]}),s[22]||(s[22]=i("来帮助 gMock 解析要使用的重载版本。",-1))]),s[78]||(s[78]=n('<h3 id="基数-对调用次数的期望" tabindex="-1"><a class="header-anchor" href="#基数-对调用次数的期望"><span>基数：对调用次数的期望</span></a></h3><p><code>EXPECT_CALL()</code> 后第一个可以指定的子句是 <code>Times()</code>。 它的参数称为<mark>基数</mark>（<em>cardinality</em>），表示对方法<strong>调用次数</strong>的期望。 使用该子句可以避免为相同的方法调用重复书写相同的期望。 不仅如此，基数还可以是模糊（<em>fuzzy</em>）值，具有很高的灵活性，能帮助用户精确表达测试意图。</p><p>基数 <code>Times(0)</code> 具有特殊含义，它表明带指定参数的调用不应发生。 若发生此类调用，gMock 将产生一个失败。</p>',3)),a("p",null,[s[24]||(s[24]=i("在前面的示例中，我们已经接触过像 ",-1)),s[25]||(s[25]=a("code",null,"AtLeast(n)",-1)),s[26]||(s[26]=i(" 这样的模糊基数。 你可以在",-1)),k(l,{href:"gmock_cheat_sheet.md#cardinality-list"},{default:h(()=>s[23]||(s[23]=[i("此处",-1)])),_:1,__:[23]}),s[27]||(s[27]=i("查阅完整的内置基数列表。",-1))]),s[79]||(s[79]=n(`<p><code>Times()</code> 子句可以省略。 若省略 <code>Times()</code>，gMock 会根据以下规则自动推断基数：</p><ul><li>若 <code>WillOnce()</code> 和 <code>WillRepeatedly()</code> 都未给定，推断为 <code>Times(1)</code>。</li><li>若存在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mo>≥</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n (\\ge 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 个 <code>WillOnce()</code>，但不存在 <code>WillRepeatedly()</code>，推断为 <code>Times(n)</code>。</li><li>若存在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n (\\ge 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 个 <code>WillOnce()</code> 和一个 <code>WillRepeatedly()</code>，推断为 <code>Times(AtLeast(n))</code>。</li></ul><div class="hint-container note"><p class="hint-container-title">思考题</p><p>若某方法预期调用两次但实际调用四次，会发生什么？</p></div><h3 id="actions-what-should-it-do" tabindex="-1"><a class="header-anchor" href="#actions-what-should-it-do"><span>动作：设置方法的行为</span></a></h3><p>模拟对象本身并不具备真正的功能实现，作为用户，我们需要指定方法被调用时的行为。</p><p>gMock 为模拟方法提供了默认行为，若用户未指定动作，则采用默认行为：</p><ul><li>当返回类型是内置类型或指针时，<code>void</code> 函数直接返回，<code>bool</code> 函数返回 <code>false</code>，其他类型返回 0。</li><li>在 C++11 及以上版本中，若返回类型具有默认构造函数，返回默认构造的值。</li></ul><p>如果模拟方法没有默认行为，或者默认行为并不适用，可以使用 <code>WillOnce()</code> 和 <code>WillRepeatedly()</code> 子句来定制方法行为。 例如：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> GetX</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">     .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillOnce</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">100</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">     .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillOnce</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">200</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">     .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillOnce</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">300</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span></code></pre></div><p>表示 <code>turtle.GetX()</code> 会被调用恰好三次（由 gMock 自动推断），且分别返回 100、200 和 300。</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> GetY</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">     .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillOnce</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">100</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">     .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillOnce</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">200</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">     .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillRepeatedly</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">300</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span></code></pre></div><p>表示 <code>turtle.GetY()</code> 会被调用至少两次（由 gMock 自动推断），前两次分别返回 100 和 200，之后始终返回 300。</p><p>如果你显示指定了 <code>Times()</code>，gMock 将不再自动推断基数。 这时，如果你指定的基数超出 <code>WillOnce()</code> 描述的数量，且没有指定 <code>WillRepeatedly()</code>，在耗尽所有 <code>WillOnce()</code> 后，方法将执行默认行为。</p>`,13)),a("p",null,[s[29]||(s[29]=i("在设置动作时，除了 ",-1)),s[30]||(s[30]=a("code",null,"Return()",-1)),s[31]||(s[31]=i(" 外，还可以使用 ",-1)),s[32]||(s[32]=a("code",null,"RuturnRef(",-1)),s[33]||(s[33]=a("em",null,[a("code",null,"variable")],-1)),s[34]||(s[34]=a("code",null,")",-1)),s[35]||(s[35]=i(" 来返回引用，或者执行其他",-1)),k(l,{href:"gmock_cook_book.md#using-actions"},{default:h(()=>s[28]||(s[28]=[i("预定义行为",-1)])),_:1,__:[28]}),s[36]||(s[36]=i("。",-1))]),a("div",A,[s[47]||(s[47]=n(`<p class="hint-container-title">注意</p><p><code>EXPECT_CALL()</code> 语句仅会执行动作子句一次，即使该动作可能被多次执行，因此需谨慎对待副作用。</p><p>例如，以下代码将无法实现预期效果：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> n </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 100</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> GetX</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Times</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">4</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillRepeatedly</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">n</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span></code></pre></div>`,4)),a("p",null,[s[38]||(s[38]=a("code",null,"n++",-1)),s[39]||(s[39]=i(" 语句只会被执行一次，因此该方法将始终返回 100，而不是 100、101、102、...。 类似地，",-1)),s[40]||(s[40]=a("code",null,"Return(new Foo)",-1)),s[41]||(s[41]=i(" 会在 ",-1)),s[42]||(s[42]=a("code",null,"EXPECT_CALL()",-1)),s[43]||(s[43]=i(" 执行时创建一个 ",-1)),s[44]||(s[44]=a("code",null,"Foo",-1)),s[45]||(s[45]=i(" 对象，之后每次都会返回相同的指针。 如果你希望副作用能够正常发生，可以使用自定义动作，这部分将在 ",-1)),k(l,{href:"gmock_cook_book.md"},{default:h(()=>s[37]||(s[37]=[i("gMock 高级技巧",-1)])),_:1,__:[37]}),s[46]||(s[46]=i("中提及。",-1))])]),a("div",o,[s[51]||(s[51]=n(`<p class="hint-container-title">思考题</p><p>思考下面代码的含义：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> GetY</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Times</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">4</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillOnce</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">100</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span></code></pre></div>`,3)),a("p",null,[s[49]||(s[49]=a("strong",null,"答案",-1)),s[50]||(s[50]=i("： ",-1)),k(p,null,{default:h(()=>s[48]||(s[48]=[i("`turtle.GetY()` 期望被调用四次，第一次返回 100，剩下三次返回 0（`int` 的默认行为）。",-1)])),_:1,__:[48]})])]),s[80]||(s[80]=n(`<h3 id="multi-expectations" tabindex="-1"><a class="header-anchor" href="#multi-expectations"><span>设置多重期望</span></a></h3><p>在前面的示例中，我们只展示了使用一个期望的情况。 在实际测试中，我们可能需要为模拟对象的某一方法设置多重期望。 默认情况下，gMock 会按照期望定义的<strong>逆序</strong>来匹配，直到遇到第一个匹配的期望（即“后定义的期望具有更高优先级”）。 如果所有期望都不匹配，则会产生一个超限错误（<em>upper-bound-violated failure</em>）。</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">_</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Forward</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">_</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // #1</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Forward</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // #2</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Times</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre></div><p>以上述代码为例，如果连续调用 3 次 <code>Forward(10)</code> ，就会产生一个错误，因为它匹配到了期望 <code>#2</code>。 如果第 3 次调用改为 <code>Forward(20)</code>，则没有问题，因为这时匹配到的是期望 <code>#1</code>。</p><div class="hint-container info"><p class="hint-container-title">设计目的</p><p>gMock 选用<strong>逆序</strong>来匹配期望，是因为这样允许用户在模拟对象的构造函数或测试套件的 <code>SetUp</code> 方法中提供默认期望， 然后在测试单元中设置更特定（<em>specific</em>）的期望来定制模拟对象。 因此，如果某个方法有两个期望，你应该将匹配器更加特定的期望放在后面，否则它会被更通用的规则给隐藏掉。</p></div>`,5)),a("div",c,[s[63]||(s[63]=a("p",{class:"hint-container-title"},"兜底期望",-1)),a("p",null,[s[53]||(s[53]=i("为方法设置一个",-1)),s[54]||(s[54]=a("strong",null,"兜底期望",-1)),s[55]||(s[55]=i("（",-1)),s[56]||(s[56]=a("em",null,"catch-all expectation",-1)),s[57]||(s[57]=i("，即匹配所有参数并设为 ",-1)),s[58]||(s[58]=a("code",null,"Times(AnyNumber())",-1)),s[59]||(s[59]=i("）的行为非常普遍。 这使得方法的任何调用都能满足预期。 对于那些根本不会涉及的方法（称为“无趣”，",-1)),s[60]||(s[60]=a("em",null,"uninteresting",-1)),s[61]||(s[61]=i("）来说，这样做没有必要； 但对于那些设置了一些期望、同时也允许其他调用方式的方法来说非常有用。 详见",-1)),k(l,{href:"gmock_cook_book.md#uninteresting-vs-unexpected"},{default:h(()=>s[52]||(s[52]=[i("理解无趣调用与意外调用",-1)])),_:1,__:[52]}),s[62]||(s[62]=i("。",-1))])]),s[81]||(s[81]=n(`<h3 id="ordered-calls" tabindex="-1"><a class="header-anchor" href="#ordered-calls"><span>有序调用 vs 无序调用</span></a></h3><p>默认情况下，即使先声明的期望尚未满足，后声明的期望依旧可以被匹配到。 也就是说，方法的实际调用顺序不需要与期望声明的顺序一致。</p><p>然而，有时我们希望方法能够严格按照期望声明的顺序调用。 在 gMock 中，可以通过 <code>InSequence</code> 方便地实现这一功能：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">InSequence</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">TEST</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">FooTest</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> DrawsLineSegment</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  ...</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    InSequence seq</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> PenDown</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">());</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Forward</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">100</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> PenUp</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">());</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  Foo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>在创建 <code>InSequence</code> 的实例后，其作用域内的所有期望会形成一个顺序链，必须按照声明顺序匹配。 由于 <code>InSequence</code> 的功能仅依赖其构造和析构函数，因此变量名无关紧要。</p><p>在这个示例中，我们验证了 <code>Foo()</code> 严格按照声明顺序调用这三个方法。 如果调用顺序错乱，将产生一个错误。</p>`,6)),a("div",D,[s[69]||(s[69]=a("p",{class:"hint-container-title"},"注",-1)),a("p",null,[s[65]||(s[65]=i("如果你只关心部分方法的调用顺序，而不是所有方法，gMock 也允许你指定任意的偏序关系（",-1)),s[66]||(s[66]=a("em",null,"arbitrary partial order",-1)),s[67]||(s[67]=i("）。 你可以在",-1)),k(l,{href:"gmock_cook_book.md#ordered-calls"},{default:h(()=>s[64]||(s[64]=[i("这里",-1)])),_:1,__:[64]}),s[68]||(s[68]=i("了解更多细节。",-1))])]),s[82]||(s[82]=n(`<h3 id="sticky-expectations" tabindex="-1"><a class="header-anchor" href="#sticky-expectations"><span>期望的持久性</span></a></h3><p>现在，让我们通过一个简单的问题来检验你对 gMock 的理解： 如何验证 <code>turtle</code> 恰好被要求移动到原点两次，同时忽略其他指令？</p><p>在查看参考答案前，请先尝试自行解答：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">_</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">AnyNumber</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> GoTo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">_</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> _</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // #1</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">     .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Times</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">AnyNumber</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">());</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> GoTo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // #2</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">     .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Times</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre></div><p>如果 <code>turtle.GoTo(0, 0)</code> 实际被调用三次，这三次调用都会匹配期望 <code>#2</code>（因为 gMock 优先匹配后定义的可用期望）。 此时，由于调用次数超出限制，gMock 将立即报错。 这部分内容我们已经在<a href="#multi-expectations">设置多重期望</a>一节中讨论过。</p><p>上面的示例说明了 gMock 的期望默认具有<mark>持久性</mark>（<em>sticky</em>）：即使达到调用次数上限，期望仍然保持活跃状态。 这是 gMock 与其他模拟框架的一个重要区别（为何如此设计？因为我们认为此规则能简化大多数情况的表达）。</p><p>你觉得这很简单？ 让我们看看你是否真正理解了这一规则——请阐述下面代码的作用：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">--</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> GetX</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">      .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillOnce</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>如果你认为此代码期望 <code>turtle.GetX()</code> 被调用 <code>n</code> 次并依次返回 10、20、30、...，不妨重新思考一下。 我们前面提到，期望具有持久性， 因此，第二次调用 <code>turtle.GetX()</code> 时，仍会匹配到最后一次循环定义的期望（即 <code>i=1</code> 时的 <code>Return(10)</code>）： 这会立刻产生一个超限错误——此代码存在严重的逻辑缺陷。</p><p>要正确实现“依次返回 10、20、30、...”的行为，你应该显式地让期望在饱和（<em>saturated</em>）后立即失效（<em>retire</em>）：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">--</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> GetX</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">      .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillOnce</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">      .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">RetiresOnSaturation</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>不过，这里我们可以使用顺序链来更优雅地解决问题：</p><div class="language-cpp" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">InSequence</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">testing</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">...</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  InSequence s</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    EXPECT_CALL</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">turtle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> GetX</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WillOnce</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">RetiresOnSaturation</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 译注：原文这里还调用了 \`RetiresOnSaturation()\`，但我认为这是不必要的，这可能是一处笔误。</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>在顺序链中，期望会在饱和后自动失效，以便后续的期望能够被匹配。 这是使期望不具备持久性的另一种方法。</p><h3 id="处理不重要方法" tabindex="-1"><a class="header-anchor" href="#处理不重要方法"><span>处理不重要方法</span></a></h3><p>模拟对象可能会有很多方法，但并非所有方法都值得我们关注。 例如，在某些测试中，我们可能不关心 <code>GetX()</code> 和 <code>GetY()</code> 的调用次数。</p>`,16)),a("p",null,[s[71]||(s[71]=i("在 gMock 中，对于不关注的方法，无需设置任何期望。 当这些方法被调用时，测试会输出警告信息，但不会导致测试失败。 这种行为称为“唠叨（",-1)),s[72]||(s[72]=a("em",null,"naggy",-1)),s[73]||(s[73]=i("）模式”。 如果你想改变该默认行为，请参考",-1)),k(l,{href:"gmock_cook_book.md#nice-strict-naggy"},{default:h(()=>s[70]||(s[70]=[i("友好模式、严格模式和唠叨模式",-1)])),_:1,__:[70]}),s[74]||(s[74]=i("。",-1))])])}const B=e(g,[["render",E]]),m=JSON.parse('{"path":"/gtest/gmock_for_dummies/","title":"gMock 入门基础","lang":"zh-CN","frontmatter":{"title":"gMock 入门基础","createTime":"2025-03-13T19:44:44.000Z","permalink":"/gtest/gmock_for_dummies/","copyright":{"creation":"translate","source":"https://google.github.io/googletest/gmock_for_dummies.html"},"description":"什么是 gMock？ 在编写原型（prototype）或测试时，完全依赖真实对象的行为往往不可行或不够明智。 模拟对象（mock object）实现了与真实对象相同的接口，可以替代真实对象。 你可以在运行时指定和观察模拟对象的行为，如“哪些方法会被调用？”“按什么顺序调用？”“调用多少次？”“使用什么参数？”“返回什么值？”等等。 人们常常会混淆伪对象...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"gMock 入门基础\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-10T08:59:20.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://sunirein.tech/gtest/gmock_for_dummies/"}],["meta",{"property":"og:site_name","content":"SuniRein 的个人小站"}],["meta",{"property":"og:title","content":"gMock 入门基础"}],["meta",{"property":"og:description","content":"什么是 gMock？ 在编写原型（prototype）或测试时，完全依赖真实对象的行为往往不可行或不够明智。 模拟对象（mock object）实现了与真实对象相同的接口，可以替代真实对象。 你可以在运行时指定和观察模拟对象的行为，如“哪些方法会被调用？”“按什么顺序调用？”“调用多少次？”“使用什么参数？”“返回什么值？”等等。 人们常常会混淆伪对象..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-10T08:59:20.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-10T08:59:20.000Z"}]]},"readingTime":{"minutes":20.31,"words":6093},"git":{"createdTime":1741866309000,"updatedTime":1754816360000,"contributors":[{"name":"SuniRein","username":"SuniRein","email":"sunirein@qq.com","commits":7,"avatar":"https://avatars.githubusercontent.com/SuniRein?v=4","url":"https://github.com/SuniRein"}]},"autoDesc":true,"filePathRelative":"notes/GoogleTest/gmock_for_dummies.md","headers":[]}');export{B as comp,m as data};
